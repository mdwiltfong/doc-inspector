{"version":3,"sources":["/app/packages/framework/src/auth.ts"],"sourcesContent":["import crypto from \"node:crypto\";\nimport { FastifyReply, FastifyRequest } from \"fastify\";\nimport { Session } from \"./Session\";\n\ndeclare module \"fastify\" {\n  interface FastifyRequest {\n    gadgetAuth?: {\n      redirectToSignIn: boolean;\n      signInPath: string;\n    };\n  }\n}\n\nexport const generateCode = (numBytes = 64): string => {\n  return crypto.randomBytes(numBytes).toString(\"hex\");\n};\n\nexport const hashCode = (code: string) => {\n  return crypto.createHash(\"sha256\").update(code).digest(\"hex\");\n};\nconst getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {\n  if (\"applicationSession\" in request) {\n    return request.applicationSession as any as Session;\n  }\n\n  throw new Error(\"The request is not a Gadget server request\");\n};\n\n/**\n * Safely compares a password reset code and hash\n * @param {string} [code] - The password reset code\n * @param {string} [hash] - The hashed password reset code\n * @returns {boolean} - Whether the code is valid or not\n */\n\n/**\n * Utility function to wrap route handlers with protection from unauthenticated requests.\n *\n * @param handler The route handler to protect\n * @param {ProtectedRouteOptions} options Options for the protected route\n * @returns handler function that is wrapped with route protection\n *\n * @example\n * ```ts\n * // routes/GET-protected-route.js\n * const { preValidation } = require(\"@gadgetinc/auth\");\n *\n * module.exports = async ({ request, reply }) => {\n *  await reply.send(\"this is a protected route\");\n * }\n *\n * module.options = {\n *  preValidation,\n * }\n * ```\n */\nexport const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply) => {\n  let authenticated = false;\n  const applicationSession = getSessionFromRequest(request);\n  authenticated = !!applicationSession.get(\"user\");\n\n  if (!authenticated) {\n    if (request.gadgetAuth?.redirectToSignIn) {\n      await reply.redirect(request.gadgetAuth.signInPath);\n    } else {\n      await reply.status(403).send();\n    }\n  }\n};\n"],"names":["generateCode","hashCode","preValidation","numBytes","crypto","randomBytes","toString","code","createHash","update","digest","getSessionFromRequest","request","applicationSession","Error","reply","authenticated","get","gadgetAuth","redirectToSignIn","redirect","signInPath","status","send"],"mappings":";;;;;;;;;;;IAaaA,YAAY;eAAZA;;IAIAC,QAAQ;eAARA;;IAuCAC,aAAa;eAAbA;;;;;;;;;;;oEAxDM;;;;;;AAaZ,MAAMF,eAAe,CAACG,WAAW,EAAE;IACxC,OAAOC,qBAAM,CAACC,WAAW,CAACF,UAAUG,QAAQ,CAAC;AAC/C;AAEO,MAAML,WAAW,CAACM;IACvB,OAAOH,qBAAM,CAACI,UAAU,CAAC,UAAUC,MAAM,CAACF,MAAMG,MAAM,CAAC;AACzD;AACA,MAAMC,wBAAwB,CAAiCC;IAC7D,IAAI,wBAAwBA,SAAS;QACnC,OAAOA,QAAQC,kBAAkB;IACnC;IAEA,MAAM,IAAIC,MAAM;AAClB;AA8BO,MAAMZ,gBAAgB,OAA4CU,SAAuBG;IAC9F,IAAIC,gBAAgB;IACpB,MAAMH,qBAAqBF,sBAAsBC;IACjDI,gBAAgB,CAAC,CAACH,mBAAmBI,GAAG,CAAC;IAEzC,IAAI,CAACD,eAAe;QAClB,IAAIJ,QAAQM,UAAU,EAAEC,kBAAkB;YACxC,MAAMJ,MAAMK,QAAQ,CAACR,QAAQM,UAAU,CAACG,UAAU;QACpD,OAAO;YACL,MAAMN,MAAMO,MAAM,CAAC,KAAKC,IAAI;QAC9B;IACF;AACF"}