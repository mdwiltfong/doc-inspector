{"version":3,"sources":["/app/packages/framework/src/state-chart/index.ts"],"sourcesContent":["import { NoTransitionError } from \"../errors\";\nimport { Globals } from \"../globals\";\nimport type { StateData, StateHistoryValue, StateMapper, StateValue } from \"./StateMapper\";\nimport { flattenStateValue } from \"./StateMapper\";\n\ntype ActionContext = any;\n/**\n * Get the states we could potentially transition from given the initial state.\n *\n * Based on the state value, we have many possible states that could receive the incoming actions. For example, with the state value\n *\n *     { \"created\": { \"unfulfilled\": \"needsReview\" } } }\n *\n * we can run actions on three possible states: \"created\", \"created.unfulfilled\", and \"created.unfulfilled.needsReview\". We flatten\n * this state value into the set of state keys for each of these to create the possible transition state.\n */\n\nexport const possibleTransitionStates = ({ record, model }: ActionContext, mapper: StateMapper) => {\n  const state = record.state;\n  if (state) {\n    const stateValue = mapper.mapApiIdentifiersToStorageValue(state);\n    return Globals.platformModules.lodash().map(flattenStateValue(stateValue), (key: string) => mapper.stateKeyToData(key));\n  } else if (model.stateChart.initialChildStateKey) {\n    const startState = mapper.stateKeyToData(model.stateChart.initialChildStateKey);\n    return [startState];\n  }\n  return [];\n};\n\n/**\n * Check if we can execute the action.\n *\n * A transition can be taken if there is a possible transition state that has the same from key as the transition we'd like to take.\n *\n * @throws {NoTransitionError} if none of the possible transition states\n */\nexport const checkCanExecute = (context: ActionContext, mapper: StateMapper) => {\n  const receivingState = Globals.platformModules\n    .lodash()\n    .find(possibleTransitionStates(context, mapper), [\"blob.key\", context.transition.fromStateKey]);\n  if (!receivingState) {\n    const {\n      record: { state },\n    } = context;\n\n    let stateName = \"<unknown>\";\n    if (Globals.platformModules.lodash().isString(state)) {\n      stateName = state;\n    } else if (Globals.platformModules.lodash().isObjectLike(state)) {\n      stateName = JSON.stringify(state);\n    } else if (context.model.stateChart.initialChildStateKey) {\n      const initialStateKey = context.model.stateChart.initialChildStateKey;\n      const state = Globals.platformModules.lodash().find(context.model.stateChart.childStates, { key: initialStateKey });\n      if (state) {\n        stateName = state.name;\n      }\n    }\n\n    let errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. Unable to execute the \"${context.action.apiIdentifier}\" action in state \"${stateName}\".`;\n    if (context.action.apiIdentifier == \"logInViaEmail\") {\n      errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. This session is already logged in for ${context.params.email}.`;\n    }\n    throw new NoTransitionError(errorMessage);\n  }\n};\n\n/**\n * Incorporate a given state value into an existing historical state.\n *\n * For example, if we have the following history and state:\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"unfulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n *\n * const state = { created: \"fulfilled\" };\n * ```\n *\n * the new historical state would be\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"fulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n * ```\n *\n * Semantically, we set the value of \"current\" (in the history) at every point along the state value \"path\".\n */\nexport const computeStateHistory = (history: StateHistoryValue, state: StateValue): StateHistoryValue => {\n  const newHistory: StateHistoryValue = history ? Globals.platformModules.lodash().cloneDeep(history) : { current: \"\" };\n  const path = [];\n  while (Globals.platformModules.lodash().isObject(state)) {\n    const [current, newState] = Object.entries(state)[0];\n\n    path.push(\"current\");\n    Globals.platformModules.lodash().set(newHistory, path, current);\n    path.pop();\n\n    path.push(\"children\");\n    path.push(current);\n\n    state = newState;\n  }\n\n  path.push(\"current\");\n  Globals.platformModules.lodash().set(newHistory, path, state);\n\n  return newHistory;\n};\n\n/**\n * Find the state value for the state we'll be transitioning into.\n *\n * For states without children, the state value will just be the state we're transitioning to.\n *\n * For states with children, we need to restore the child state from history. A historical value is used if:\n * 1. there actually is a historical value (in other words, is not `undefined`),\n * 2. the state requests history to be restored, and\n * 3. the historical value is for a nested state that actually exists.\n *\n * We recursively repeat the above. Once finished, if we're still at a state that has children, we go as deep as possible using the\n * child states that are configured to be the initial.\n */\nexport const computeStateValueFor = (history: StateHistoryValue, state: StateData, mapper: StateMapper): StateValue => {\n  // This will be the \"path\" to the penultimate state in the state value we return. For example, if the state value we\n  // return is `{ a: { b: \"c\" } }`, the path will be `[\"a\", \"b\"]`.\n  const path = Globals.platformModules.lodash().clone(state.path);\n\n  // A path to dig into the historical value. The historical value nests every state under \"children\", hence the `flatMap`.\n  const historyPath = path.flatMap((segment: string) => [\"children\", segment]);\n\n  while (state.blob.initialChildStateKey) {\n    // Rule (2) above\n    if (state.blob.restoreHistory) {\n      // The value we potentially want to restore is under the \"current\" key in the history value, so temporarily push \"current\" into the\n      // path so we can grab it, but pop it again because we may recurse further.\n      historyPath.push(\"current\");\n      const apiIdentifier = Globals.platformModules.lodash().get(history, historyPath) as string;\n      historyPath.pop();\n\n      // Rules (1) and (3) above. If there's no historical value, the `get` above will return undefined, and no child state should\n      // have an undefined API identifier, so we'll hit the break below.\n      const maybeChildState = Globals.platformModules.lodash().find(state.blob.childStates, { apiIdentifier });\n      if (maybeChildState) {\n        historyPath.push(\"children\");\n        historyPath.push(apiIdentifier);\n        path.push(apiIdentifier);\n        state = mapper.stateKeyToData(maybeChildState.key);\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  path.pop();\n\n  // Now that we've went as deep into history as possible, initial the rest of the nested states with the initial states\n  while (state.blob.initialChildStateKey) {\n    path.push(state.blob.apiIdentifier);\n    state = mapper.stateKeyToData(state.blob.initialChildStateKey);\n  }\n\n  // Special case for a root state, just return the API identifier. For example, if the created state has no nested states, the\n  // actual state value will be `\"created\"`, not `{ created: ??? }`.\n  if (Globals.platformModules.lodash().isEmpty(path)) {\n    return state.apiIdentifier;\n  }\n\n  // `set` will ensure all intermediate objects are initialized. So `set({}, ['a', 'b'], 'c')` will give us `{ a: { b: \"c\" } }`\n  return Globals.platformModules.lodash().set({}, path, state.apiIdentifier);\n};\n\nexport const _doStateTransition = (\n  currentHistory: StateHistoryValue,\n  currentState: StateValue,\n  toState: StateData,\n  mapper: StateMapper,\n  record: any\n) => {\n  const newHistory = computeStateHistory(currentHistory, currentState);\n\n  // It's important that we use the new history value here, instead of `recordStateHistory`, in case of a self transition. The historical\n  // value contains the position we were in _previously_. That means that if we did a self transition, we'd revert to the previous state\n  // (if it were different than the current state).\n  const newState = computeStateValueFor(newHistory, toState, mapper);\n\n  record.state = newState;\n  record.stateHistory = newHistory;\n  return { newState, newHistory };\n};\n\nexport const doStateTransition = (context: ActionContext, mapper: StateMapper) => {\n  const toState = mapper.stateKeyToData(context.transition.toStateKey);\n  const currentState = Globals.platformModules.lodash().cloneDeep(context.record.state);\n  const currentHistory = Globals.platformModules.lodash().cloneDeep(context.record.stateHistory);\n\n  return _doStateTransition(currentHistory, currentState, toState, mapper, context.record);\n};\n\n// In case the state still hasn't been persisted, ensure the state change still happens\nexport const persistStateTransition = async (newState: any, newHistory: any, context: ActionContext) => {\n  if (context.record.changed(\"state\") || context.record.changed(\"stateHistory\")) {\n    await updateState(context, newState, newHistory);\n  }\n};\n\n/** Persist the new state into the model record */\nexport const updateState = async (\n  { api, model, record, scope, logger }: ActionContext,\n  newState: StateValue,\n  stateHistory: StateHistoryValue\n) => {\n  if (record.id && !scope.recordDeleted) {\n    await api.internal[model.apiIdentifier].update(record.id, { [model.apiIdentifier]: { state: newState, stateHistory } });\n    logger.debug(\"updated record state\");\n  }\n};\n\nexport { StateMapper, isStateHistoryValue, isStateValue } from \"./StateMapper\";\nexport type { StateHistoryValue, StateValue, StateValueMap } from \"./StateMapper\";\n"],"names":["possibleTransitionStates","checkCanExecute","computeStateHistory","computeStateValueFor","_doStateTransition","doStateTransition","persistStateTransition","updateState","StateMapper","isStateHistoryValue","isStateValue","record","model","mapper","state","stateValue","mapApiIdentifiersToStorageValue","Globals","platformModules","lodash","map","flattenStateValue","key","stateKeyToData","stateChart","initialChildStateKey","startState","context","receivingState","find","transition","fromStateKey","stateName","isString","isObjectLike","JSON","stringify","initialStateKey","childStates","name","errorMessage","apiIdentifier","action","params","email","NoTransitionError","history","newHistory","cloneDeep","current","path","isObject","newState","Object","entries","push","set","pop","clone","historyPath","flatMap","segment","blob","restoreHistory","get","maybeChildState","isEmpty","currentHistory","currentState","toState","stateHistory","toStateKey","changed","api","scope","logger","id","recordDeleted","internal","update","debug"],"mappings":"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"}